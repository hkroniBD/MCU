# Arduino Microcontroller Features - Complete Guide

## Introduction

Arduino is built around microcontrollers (primarily the ATmega328P in Arduino Uno), and understanding its features is essential for designing effective embedded systems. This note explains each feature in detail with practical examples and applications.

---

## 1. Digital Input/Output (GPIO) Pins

### What Are They?

**GPIO (General Purpose Input/Output)** pins are programmable pins that can read or write digital signals.

**Arduino Uno Specifications:**
- **14 digital pins** (pins 0-13)
- Each pin can be configured as INPUT or OUTPUT
- Logic levels: HIGH (5V) or LOW (0V)
- Current per pin: 20mA maximum (40mA absolute max - not recommended)
- Total current for all pins: 200mA maximum

### How They Work

**As OUTPUT:**
```cpp
pinMode(13, OUTPUT);      // Configure pin 13 as output
digitalWrite(13, HIGH);   // Set pin to 5V (LED ON)
digitalWrite(13, LOW);    // Set pin to 0V (LED OFF)
```

**As INPUT:**
```cpp
pinMode(2, INPUT);             // Configure pin 2 as input
int state = digitalRead(2);    // Read pin state (HIGH or LOW)

// With internal pull-up resistor
pinMode(2, INPUT_PULLUP);      // Enables 20-47kΩ pull-up
```

### Practical Applications

**1. Controlling LEDs:**
```cpp
// Blink pattern
digitalWrite(13, HIGH);
delay(100);
digitalWrite(13, LOW);
delay(100);
```

**2. Reading Buttons/Switches:**
```cpp
if (digitalRead(buttonPin) == LOW) {
  // Button pressed (assuming pull-up configuration)
  // Perform action
}
```

**3. Controlling Relays:**
- Switch high-power devices (motors, lamps, appliances)
- Arduino pin → Transistor → Relay coil

**4. Interfacing with Digital Sensors:**
- PIR motion sensors
- Reed switches (magnetic door sensors)
- Infrared receivers

### Important Considerations

⚠️ **Current Limitations**: Never draw more than 20mA per pin
- Use transistors for loads > 20mA
- External power for motors, relays, high-power LEDs

⚠️ **Voltage Levels**: Arduino Uno operates at 5V logic
- 3.3V devices need level shifters
- Never connect pins directly to higher voltages

---

## 2. Analog Input Pins (ADC)

### What Are They?

**ADC (Analog-to-Digital Converter)** converts continuous analog voltages into discrete digital values that the microcontroller can process.

**Arduino Uno Specifications:**
- **6 analog input pins** (A0-A5)
- **10-bit resolution**: 2^10 = 1024 possible values (0-1023)
- **Input voltage range**: 0V to 5V (or 0V to AREF voltage)
- **Conversion time**: ~100 microseconds per reading
- **Reference voltage**: 5V default (configurable)

### Understanding Resolution

```
Voltage Range: 0V to 5V
Resolution: 5V / 1024 = 0.00488V ≈ 4.88mV per step

Voltage    →    ADC Value
0.000V     →    0
0.005V     →    1
1.250V     →    256
2.500V     →    512
3.750V     →    768
5.000V     →    1023
```

### How to Use

```cpp
int sensorPin = A0;

void setup() {
  Serial.begin(9600);
  // Analog pins don't need pinMode configuration
}

void loop() {
  int rawValue = analogRead(sensorPin);  // Returns 0-1023
  
  // Convert to voltage
  float voltage = rawValue * (5.0 / 1023.0);
  
  Serial.print("Raw: ");
  Serial.print(rawValue);
  Serial.print(" | Voltage: ");
  Serial.println(voltage);
  
  delay(100);
}
```

### Voltage Reference Options

```cpp
// Use default 5V reference
analogReference(DEFAULT);

// Use internal 1.1V reference (better precision for low voltages)
analogReference(INTERNAL);

// Use external reference voltage on AREF pin
analogReference(EXTERNAL);
```

**Example with 1.1V reference:**
```cpp
analogReference(INTERNAL);  // 1.1V reference
delay(100);  // Allow reference to stabilize

int value = analogRead(A0);
float voltage = value * (1.1 / 1023.0);  // Now each step = 1.07mV
```

### Practical Applications

**1. Temperature Sensing:**
```cpp
// TMP36 sensor
int reading = analogRead(tempPin);
float voltage = reading * (5.0 / 1023.0);
float temperatureC = (voltage - 0.5) * 100.0;
```

**2. Light Level Detection:**
```cpp
// Photoresistor (LDR)
int lightLevel = analogRead(ldrPin);
if (lightLevel < 300) {
  // It's dark - turn on lights
}
```

**3. Joystick Reading:**
```cpp
int xPosition = analogRead(A0);  // 0-1023
int yPosition = analogRead(A1);  // 0-1023
int buttonState = digitalRead(2);
```

**4. Battery Voltage Monitoring:**
```cpp
// With voltage divider
int raw = analogRead(batteryPin);
float batteryVoltage = raw * (5.0 / 1023.0) * 2.0;  // If using 2:1 divider
```

**5. Sensor Calibration:**
```cpp
// Map sensor range to useful values
int sensorValue = analogRead(A0);
int percentage = map(sensorValue, 0, 1023, 0, 100);
```

### Important Notes

⚠️ **Input Protection**: Analog pins can be damaged by voltages above 5V
- Use voltage dividers for higher voltages
- Add protection diodes for safety

⚠️ **Noise Reduction**:
```cpp
// Take multiple readings and average
int getStableReading(int pin) {
  long sum = 0;
  for(int i = 0; i < 10; i++) {
    sum += analogRead(pin);
    delay(10);
  }
  return sum / 10;
}
```

---

## 3. PWM (Pulse Width Modulation) Pins

### What is PWM?

PWM creates **analog-like output** using rapid digital switching. By varying the duty cycle (percentage of time HIGH vs LOW), you can control average voltage/power.

**Arduino Uno PWM Pins:**
- **6 PWM-capable pins**: 3, 5, 6, 9, 10, 11 (marked with ~)
- **Frequency**: ~490 Hz (pins 3,9,10,11) or ~980 Hz (pins 5,6)
- **Resolution**: 8-bit (0-255 levels)

### How PWM Works

```
Duty Cycle = (Time HIGH / Total Period) × 100%

0% (analogWrite 0):      Always LOW
┌────┬────┬────┬────
│    │    │    │       Average = 0V
└────┴────┴────┴────

25% (analogWrite 64):    25% HIGH, 75% LOW
┌─┬──┬─┬──┬─┬──┬─┬──
│ │  │ │  │ │  │ │     Average = 1.25V
└─┴──┴─┴──┴─┴──┴─┴──

50% (analogWrite 127):   50% HIGH, 50% LOW
┌──┬──┬──┬──┬──┬──┬──
│  │  │  │  │  │  │     Average = 2.5V
└──┴──┴──┴──┴──┴──┴──

75% (analogWrite 191):   75% HIGH, 25% LOW
┌───┬┬───┬┬───┬┬───┬
│   ││   ││   ││   │   Average = 3.75V
└───┴┴───┴┴───┴┴───┴

100% (analogWrite 255):  Always HIGH
┌────────────────────
│                       Average = 5V
┴────────────────────
```

### Using PWM

```cpp
int pwmPin = 9;

void setup() {
  pinMode(pwmPin, OUTPUT);
}

void loop() {
  analogWrite(pwmPin, 0);     // 0% duty = 0V average
  delay(1000);
  
  analogWrite(pwmPin, 64);    // 25% duty = 1.25V average
  delay(1000);
  
  analogWrite(pwmPin, 127);   // 50% duty = 2.5V average
  delay(1000);
  
  analogWrite(pwmPin, 191);   // 75% duty = 3.75V average
  delay(1000);
  
  analogWrite(pwmPin, 255);   // 100% duty = 5V average
  delay(1000);
}
```

### Practical Applications

**1. LED Brightness Control:**
```cpp
// Smooth fading
for (int brightness = 0; brightness <= 255; brightness++) {
  analogWrite(ledPin, brightness);
  delay(10);
}
```

**2. DC Motor Speed Control:**
```cpp
int motorPin = 9;
int speed = 150;  // 59% speed (150/255)

analogWrite(motorPin, speed);
```

**3. Servo Motor Control (using PWM):**
```cpp
#include <Servo.h>
Servo myServo;

void setup() {
  myServo.attach(9);  // Connects servo to pin 9
}

void loop() {
  myServo.write(0);    // 0 degrees
  delay(1000);
  myServo.write(90);   // 90 degrees
  delay(1000);
  myServo.write(180);  // 180 degrees
  delay(1000);
}
```

**4. RGB LED Color Mixing:**
```cpp
int redPin = 9;
int greenPin = 10;
int bluePin = 11;

void setColor(int red, int green, int blue) {
  analogWrite(redPin, red);
  analogWrite(greenPin, green);
  analogWrite(bluePin, blue);
}

// Purple color
setColor(255, 0, 255);
```

**5. Audio Tone Generation:**
```cpp
tone(speakerPin, 440);  // Play 440Hz (A note)
delay(1000);
noTone(speakerPin);     // Stop
```

**6. Heating Element Control:**
```cpp
// Temperature control with PWM
int dutyCycle = map(targetTemp, 0, 100, 0, 255);
analogWrite(heaterPin, dutyCycle);
```

### Important Considerations

⚠️ **PWM Frequency**: Default ~490Hz works for most applications
- Too low: visible LED flickering
- Motors/servos: 50-490Hz typical
- Audio: need 20Hz-20kHz range

⚠️ **Load Capacity**: PWM pins limited to 20mA
- Use MOSFET/transistor for higher currents
- External driver circuits for motors

---

## 4. Serial Communication (UART)

### What is UART?

**UART (Universal Asynchronous Receiver/Transmitter)** enables serial data transmission between Arduino and other devices (computer, sensors, other Arduinos).

**Arduino Uno UART:**
- **Pins**: Pin 0 (RX) and Pin 1 (TX)
- **Hardware UART**: ATmega328P has 1 hardware serial port
- **Baud rates**: 300 to 2,000,000 bps (common: 9600, 115200)
- **USB connection**: Uses hardware UART through USB-to-Serial chip

### Serial Communication Basics

```
Arduino TX  ───────>  RX Device
Arduino RX  <───────  TX Device
GND         ──────── GND

Important: TX → RX, RX → TX (crossover)
```

### Basic Serial Functions

```cpp
void setup() {
  Serial.begin(9600);  // Initialize at 9600 baud
  
  Serial.print("Hello");           // Print without newline
  Serial.println("World");         // Print with newline
  Serial.print(123);                // Print number
  Serial.print(3.14159, 2);        // Print float (2 decimals)
  Serial.write(65);                 // Send byte (ASCII 'A')
}

void loop() {
  if (Serial.available() > 0) {    // Check if data received
    char incoming = Serial.read();  // Read one byte
    Serial.print("Received: ");
    Serial.println(incoming);
  }
}
```

### Advanced Serial Techniques

**1. Reading Strings:**
```cpp
void loop() {
  if (Serial.available() > 0) {
    String message = Serial.readStringUntil('\n');
    Serial.print("You sent: ");
    Serial.println(message);
  }
}
```

**2. Parsing Comma-Separated Values:**
```cpp
// Input: "255,128,64"
if (Serial.available() > 0) {
  String data = Serial.readStringUntil('\n');
  
  int firstComma = data.indexOf(',');
  int secondComma = data.indexOf(',', firstComma + 1);
  
  int red = data.substring(0, firstComma).toInt();
  int green = data.substring(firstComma + 1, secondComma).toInt();
  int blue = data.substring(secondComma + 1).toInt();
  
  setRGBColor(red, green, blue);
}
```

**3. Formatted Output:**
```cpp
int temperature = 25;
float voltage = 3.14;

Serial.print("Temp: ");
Serial.print(temperature);
Serial.print("°C | Voltage: ");
Serial.print(voltage, 2);  // 2 decimal places
Serial.println("V");
// Output: Temp: 25°C | Voltage: 3.14V
```

**4. Binary Data Transfer:**
```cpp
byte data[] = {0x45, 0x23, 0xA1};
Serial.write(data, 3);  // Send 3 bytes
```

### Practical Applications

**1. Debugging:**
```cpp
void loop() {
  int sensor = analogRead(A0);
  Serial.print("Time: ");
  Serial.print(millis());
  Serial.print("ms | Sensor: ");
  Serial.println(sensor);
  delay(500);
}
```

**2. Remote Control via Serial:**
```cpp
void loop() {
  if (Serial.available() > 0) {
    char command = Serial.read();
    
    switch(command) {
      case '1':
        digitalWrite(LED1, HIGH);
        break;
      case '0':
        digitalWrite(LED1, LOW);
        break;
      case 'S':
        reportStatus();
        break;
    }
  }
}
```

**3. Data Logging:**
```cpp
void loop() {
  float temp = readTemperature();
  float humidity = readHumidity();
  
  // CSV format for spreadsheet
  Serial.print(millis());
  Serial.print(",");
  Serial.print(temp);
  Serial.print(",");
  Serial.println(humidity);
  
  delay(60000);  // Log every minute
}
```

**4. Communicating with Other Arduinos:**
```cpp
// Arduino 1 (Sender)
Serial.begin(9600);
Serial.println("SENSOR:25.5");

// Arduino 2 (Receiver)
if (Serial.available() > 0) {
  String data = Serial.readStringUntil('\n');
  // Process data
}
```

**5. Software Serial (Extra UART):**
```cpp
#include <SoftwareSerial.h>

SoftwareSerial mySerial(10, 11);  // RX, TX

void setup() {
  Serial.begin(9600);      // Hardware serial (USB)
  mySerial.begin(9600);    // Software serial (GPS, Bluetooth)
}

void loop() {
  if (mySerial.available()) {
    char c = mySerial.read();
    Serial.write(c);  // Forward to computer
  }
}
```

### Important Notes

⚠️ **Pins 0 and 1**: Avoid using for other purposes when using USB serial
⚠️ **Baud Rate**: Both devices must use same baud rate
⚠️ **Voltage Levels**: Arduino uses 5V logic (use level shifters for 3.3V devices)

---

## 5. Timers and Time Functions

### Built-in Time Functions

**Arduino provides several timing functions without requiring timer configuration:**

```cpp
// millis() - Returns milliseconds since Arduino started
unsigned long currentTime = millis();

// micros() - Returns microseconds
unsigned long preciseTime = micros();

// delay() - Blocking delay in milliseconds
delay(1000);  // Wait 1 second

// delayMicroseconds() - Blocking delay in microseconds
delayMicroseconds(100);  // Wait 100µs
```

### Non-Blocking Timing Patterns

**Problem with delay()**: Blocks all other code execution

**Solution: Blink Without delay()**
```cpp
unsigned long previousMillis = 0;
const long interval = 1000;  // 1 second

void loop() {
  unsigned long currentMillis = millis();
  
  if (currentMillis - previousMillis >= interval) {
    previousMillis = currentMillis;
    
    // Toggle LED
    digitalWrite(ledPin, !digitalRead(ledPin));
  }
  
  // Other code runs here without blocking
  checkSensors();
  updateDisplay();
}
```

### Multiple Timers Pattern

```cpp
// Track different events independently
unsigned long ledTimer = 0;
unsigned long sensorTimer = 0;
unsigned long displayTimer = 0;

const long LED_INTERVAL = 500;
const long SENSOR_INTERVAL = 1000;
const long DISPLAY_INTERVAL = 2000;

void loop() {
  unsigned long now = millis();
  
  // Blink LED every 500ms
  if (now - ledTimer >= LED_INTERVAL) {
    ledTimer = now;
    toggleLED();
  }
  
  // Read sensor every 1000ms
  if (now - sensorTimer >= SENSOR_INTERVAL) {
    sensorTimer = now;
    readSensors();
  }
  
  // Update display every 2000ms
  if (now - displayTimer >= DISPLAY_INTERVAL) {
    displayTimer = now;
    updateDisplay();
  }
}
```

### Hardware Timers (Advanced)

**Arduino Uno has 3 hardware timers:**
- **Timer0**: 8-bit, used by delay(), millis(), micros()
- **Timer1**: 16-bit, used by Servo library
- **Timer2**: 8-bit, available for custom use

**Using Timer Interrupts:**
```cpp
// Generate interrupt every 1 second
void setup() {
  cli();  // Disable interrupts
  
  // Configure Timer1
  TCCR1A = 0;
  TCCR1B = 0;
  TCNT1 = 0;
  
  OCR1A = 15624;  // Compare value for 1Hz
  TCCR1B |= (1 << WGM12);  // CTC mode
  TCCR1B |= (1 << CS12) | (1 << CS10);  // 1024 prescaler
  TIMSK1 |= (1 << OCIE1A);  // Enable interrupt
  
  sei();  // Enable interrupts
}

ISR(TIMER1_COMPA_vect) {
  // This runs exactly every 1 second
  digitalWrite(ledPin, !digitalRead(ledPin));
}
```

### Practical Applications

**1. Debouncing Buttons:**
```cpp
unsigned long lastDebounceTime = 0;
unsigned long debounceDelay = 50;
int buttonState = HIGH;
int lastButtonState = HIGH;

void loop() {
  int reading = digitalRead(buttonPin);
  
  if (reading != lastButtonState) {
    lastDebounceTime = millis();
  }
  
  if ((millis() - lastDebounceTime) > debounceDelay) {
    if (reading != buttonState) {
      buttonState = reading;
      
      if (buttonState == LOW) {
        // Button pressed
      }
    }
  }
  
  lastButtonState = reading;
}
```

**2. Timeout Detection:**
```cpp
unsigned long startTime = millis();
const long TIMEOUT = 5000;  // 5 seconds

while (condition) {
  if (millis() - startTime >= TIMEOUT) {
    Serial.println("Timeout!");
    break;
  }
  // Wait for something
}
```

**3. Precise Pulse Generation:**
```cpp
void sendPulse() {
  digitalWrite(pin, HIGH);
  delayMicroseconds(10);  // 10µs pulse
  digitalWrite(pin, LOW);
}
```

**4. Event Scheduling:**
```cpp
struct Event {
  unsigned long time;
  void (*function)();
};

Event events[10];
int eventCount = 0;

void scheduleEvent(unsigned long delay, void (*func)()) {
  events[eventCount].time = millis() + delay;
  events[eventCount].function = func;
  eventCount++;
}

void checkEvents() {
  unsigned long now = millis();
  for (int i = 0; i < eventCount; i++) {
    if (now >= events[i].time) {
      events[i].function();  // Execute
      // Remove event
      for (int j = i; j < eventCount - 1; j++) {
        events[j] = events[j + 1];
      }
      eventCount--;
      i--;
    }
  }
}
```

### Timing Precautions

⚠️ **millis() Overflow**: Resets after ~49 days
```cpp
// Safe subtraction handles overflow
unsigned long diff = currentMillis - previousMillis;
if (diff >= interval) {
  // Time has passed
}
```

⚠️ **Interrupt Timing**: Keep ISR code short and fast
⚠️ **delay() in ISR**: NEVER use delay() inside interrupt service routine

---

## 6. Interrupts

### What Are Interrupts?

**Interrupts** allow the microcontroller to respond immediately to events, pausing normal code execution.

**Think of it like**: You're reading a book (main program), your phone rings (interrupt), you answer the call (ISR - Interrupt Service Routine), then resume reading (return to main program).

**Arduino Uno Interrupt Pins:**
- **Pin 2**: External Interrupt 0 (INT0)
- **Pin 3**: External Interrupt 1 (INT1)
- **Pin Change Interrupts**: Available on all pins (more complex)

### Types of Interrupts

**1. External Interrupts (Pins 2 & 3):**
```cpp
volatile int counter = 0;

void setup() {
  pinMode(2, INPUT_PULLUP);
  
  // Attach interrupt to pin 2
  attachInterrupt(digitalPinToInterrupt(2), countPulse, FALLING);
  
  Serial.begin(9600);
}

void loop() {
  Serial.println(counter);
  delay(1000);
}

// Interrupt Service Routine (ISR)
void countPulse() {
  counter++;  // Increment on each pulse
}
```

**Trigger Modes:**
```cpp
attachInterrupt(pin, ISR, mode);

// Modes:
LOW     // Trigger when pin is LOW
CHANGE  // Trigger on any change (HIGH→LOW or LOW→HIGH)
RISING  // Trigger on rising edge (LOW→HIGH)
FALLING // Trigger on falling edge (HIGH→LOW)
```

**2. Timer Interrupts:**
Already covered in Timer section above.

**3. Pin Change Interrupts (All Pins):**
```cpp
#include <PinChangeInt.h>

void setup() {
  PCintPort::attachInterrupt(A0, handleA0, CHANGE);
}

void handleA0() {
  // Responds to A0 changes
}
```

### ISR Best Practices

**Rules for ISR Functions:**

✅ **DO:**
- Keep it SHORT and FAST
- Use `volatile` for shared variables
- Set flags for main loop to process
- Disable interrupts if accessing shared data

❌ **DON'T:**
- Use delay()
- Use Serial.print() (unreliable)
- Perform complex calculations
- Call millis() (won't update inside ISR)

**Good ISR Pattern:**
```cpp
volatile bool dataReady = false;
volatile int sensorValue = 0;

void setup() {
  attachInterrupt(0, handleSensor, FALLING);
}

void loop() {
  if (dataReady) {
    // Process in main loop
    Serial.println(sensorValue);
    dataReady = false;
  }
}

void handleSensor() {
  sensorValue = analogRead(A0);  // Quick read
  dataReady = true;  // Set flag
}
```

### Practical Applications

**1. Rotary Encoder:**
```cpp
volatile long position = 0;
int lastEncoded = 0;

void setup() {
  pinMode(encoderPinA, INPUT_PULLUP);
  pinMode(encoderPinB, INPUT_PULLUP);
  
  attachInterrupt(digitalPinToInterrupt(encoderPinA), updateEncoder, CHANGE);
  attachInterrupt(digitalPinToInterrupt(encoderPinB), updateEncoder, CHANGE);
}

void updateEncoder() {
  int MSB = digitalRead(encoderPinA);
  int LSB = digitalRead(encoderPinB);
  
  int encoded = (MSB << 1) | LSB;
  int sum = (lastEncoded << 2) | encoded;
  
  if (sum == 0b1101 || sum == 0b0100 || sum == 0b0010 || sum == 0b1011) position++;
  if (sum == 0b1110 || sum == 0b0111 || sum == 0b0001 || sum == 0b1000) position--;
  
  lastEncoded = encoded;
}
```

**2. Frequency Counter:**
```cpp
volatile unsigned long pulseCount = 0;
unsigned long lastTime = 0;

void setup() {
  attachInterrupt(0, countPulse, RISING);
}

void loop() {
  if (millis() - lastTime >= 1000) {
    float frequency = pulseCount;
    Serial.print(frequency);
    Serial.println(" Hz");
    
    pulseCount = 0;
    lastTime = millis();
  }
}

void countPulse() {
  pulseCount++;
}
```

**3. Emergency Stop Button:**
```cpp
volatile bool emergencyStop = false;

void setup() {
  attachInterrupt(0, handleEmergency, FALLING);
}

void loop() {
  if (emergencyStop) {
    stopAllMotors();
    while(1);  // Halt system
  }
  
  // Normal operation
  runMotors();
}

void handleEmergency() {
  emergencyStop = true;
}
```

### Critical Sections

**Protecting shared data:**
```cpp
volatile long sharedVariable = 0;

void loop() {
  long temp;
  
  // Disable interrupts while reading
  noInterrupts();
  temp = sharedVariable;
  interrupts();
  
  // Now safe to use temp
  Serial.println(temp);
}
```

---

## 7. Memory Architecture

### Memory Types in Arduino

**1. Flash Memory (Program Storage)**
- **Size**: 32 KB (Uno)
- **Purpose**: Stores your uploaded sketch
- **Bootloader**: Uses ~0.5 KB
- **Non-volatile**: Persists when powered off
- **Write cycles**: ~10,000 times

**2. SRAM (Static RAM)**
- **Size**: 2 KB (Uno)
- **Purpose**: Variables during runtime
- **Volatile**: Lost when powered off
- **Fast access**: For active data

**3. EEPROM (Electrically Erasable Programmable ROM)**
- **Size**: 1 KB (Uno)
- **Purpose**: Store data permanently
- **Non-volatile**: Persists when powered off
- **Write cycles**: ~100,000 times
- **Slower**: Takes ~3.3ms per byte write

### Memory Usage

**Check memory usage:**
```
Sketch uses 1234 bytes (3%) of program storage space.
Global variables use 56 bytes (2%) of dynamic memory,
leaving 1992 bytes for local variables.
```

### Using EEPROM

```cpp
#include <EEPROM.h>

void setup() {
  // Write single byte
  EEPROM.write(0, 255);
  
  // Read single byte
  byte value = EEPROM.read(0);
  
  // Write integer (uses 2 bytes)
  EEPROM.put(0, 12345);
  
  // Read integer
  int number;
  EEPROM.get(0, number);
  
  // Update (only writes if different - saves write cycles)
  EEPROM.update(10, 42);
}
```

**Practical Example - Save Settings:**
```cpp
struct Settings {
  int brightness;
  bool autoMode;
  float threshold;
};

Settings mySettings = {128, true, 3.14};

void saveSettings() {
  EEPROM.put(0, mySettings);
}

void loadSettings() {
  EEPROM.get(0, mySettings);
}

void setup() {
  loadSettings();  // Restore on startup
}
```

### Memory Optimization Tips

**1. Use PROGMEM for Constants:**
```cpp
// Store strings in flash instead of RAM
const char message[] PROGMEM = "This is stored in flash memory";

void setup() {
  char buffer[50];
  strcpy_P(buffer, message);  // Copy from program memory
  Serial.println(buffer);
}
```

**2. Minimize Global Variables:**
```cpp
// Bad (uses RAM)
String longMessage = "Very long text...";

// Good (uses flash)
const char longMessage[] PROGMEM = "Very long text...";
```

**3. Use Smaller Data Types:**
```cpp
// Bad
int ledState = 0;  // Uses 2 bytes for 0/1

// Good
bool ledState = false;  // Uses 1 byte
byte brightness = 128;  // Uses 1 byte (0-255)
```

---

# Arduino Microcontroller Features - Complete Guide (Continued)

## 8. Power Management (Continued)

### Sleep Modes Implementation

```cpp
#include <avr/sleep.h>
#include <avr/power.h>

void enterSleep() {
  // Setup for deepest sleep
  set_sleep_mode(SLEEP_MODE_PWR_DOWN);
  sleep_enable();
  
  // Disable ADC to save power
  ADCSRA &= ~(1 << ADEN);
  
  // Disable Brown-Out Detector (requires special fuse settings)
  // sleep_bod_disable();
  
  // Enter sleep mode
  noInterrupts();  // Ensure no interrupts occur during setup
  sleep_cpu();
  
  // Code resumes here after wake-up
  sleep_disable();
  
  // Re-enable ADC if needed
  ADCSRA |= (1 << ADEN);
}

// Wake up via external interrupt on pin 2
void setup() {
  pinMode(2, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(2), wakeUp, FALLING);
}

void wakeUp() {
  // Minimal code - just wake up
}

void loop() {
  Serial.println("Awake!");
  delay(1000);
  
  Serial.println("Going to sleep...");
  delay(100);
  enterSleep();
}
```

### Available Sleep Modes

```cpp
// Power consumption (typical):
SLEEP_MODE_IDLE        // 15mA - CPU stopped, peripherals running
SLEEP_MODE_ADC         // 6.5mA - ADC noise reduction
SLEEP_MODE_PWR_SAVE    // 1.5mA - Timer2 running
SLEEP_MODE_STANDBY     // 1.5mA - Oscillator running
SLEEP_MODE_PWR_DOWN    // 0.1mA - Deepest sleep (external interrupt only)
```

### Wake-up Sources

**1. External Interrupt:**
```cpp
attachInterrupt(digitalPinToInterrupt(2), wakeUp, LOW);
enterSleep();  // Will wake on pin 2 going LOW
```

**2. Pin Change Interrupt (any pin):**
```cpp
PCMSK2 |= (1 << PCINT18);  // Pin D2
PCICR |= (1 << PCIE2);     // Enable PCI group 2
```

**3. Watchdog Timer:**
```cpp
#include <avr/wdt.h>

void setupWatchdog() {
  wdt_disable();  // Disable for configuration
  
  // Configure watchdog for 8 seconds timeout
  WDTCSR |= (1 << WDCE) | (1 << WDE);
  WDTCSR = (1 << WDP3) | (1 << WDP0);  // 8 seconds
  WDTCSR |= (1 << WDIE);  // Enable interrupt mode
  
  wdt_reset();  // Start the timer
}

ISR(WDT_vect) {
  // Wake up here
}
```

**4. Timer Interrupt:**
```cpp
// Configure Timer1 to wake from sleep
TIMSK1 |= (1 << OCIE1A);  // Enable compare match interrupt
```

### Power-Saving Techniques

**1. Disable Unused Peripherals:**
```cpp
void disablePeripherals() {
  // Disable ADC
  ADCSRA = 0;
  
  // Disable analog comparator
  ACSR |= (1 << ACD);
  
  // Disable USART if not used
  UCSR0B = 0;
  
  // Disable SPI if not used
  SPCR = 0;
  
  // Disable TWI (I2C) if not used
  TWCR = 0;
  
  // Disable Timer0 (affects delay(), millis(), micros())
  // TIMSK0 = 0;
  
  // Disable Timer1
  TIMSK1 = 0;
  
  // Disable Timer2
  TIMSK2 = 0;
}
```

**2. Reduce Clock Speed:**
```cpp
// Modify clock prescaler (use carefully!)
void setClockPrescaler() {
  cli();  // Disable interrupts
  
  CLKPR = (1 << CLKPCE);  // Enable prescaler change
  CLKPR = (1 << CLKPS0);  // Divide by 2 (8MHz → 4MHz)
  
  sei();  // Re-enable interrupts
}
```

**3. Lower Operating Voltage:**
```cpp
// Use 3.3V operation with appropriate regulator
// Reduces power consumption significantly
// Note: ATmega328P can run at 1.8V-5.5V
```

**4. Turn Off LEDs:**
```cpp
pinMode(LED_BUILTIN, INPUT);  // High impedance saves power
// Or set as OUTPUT and LOW
```

### Practical Battery-Powered Applications

**Example: Low-Power Data Logger**
```cpp
#include <avr/sleep.h>
#include <EEPROM.h>

volatile bool wakeFlag = false;
int logInterval = 60000;  // Log every minute
int eepromAddress = 0;

void setup() {
  // Minimal setup for power saving
  disablePeripherals();
  
  // Setup wake timer (Watchdog)
  setupWatchdogTimer();
  
  // Setup sensor
  setupSensor();
}

void loop() {
  if (wakeFlag) {
    wakeFlag = false;
    
    // Take measurement
    float temperature = readTemperature();
    
    // Store in EEPROM
    EEPROM.put(eepromAddress, temperature);
    eepromAddress += sizeof(float);
    
    // Check memory limit
    if (eepromAddress >= EEPROM.length() - sizeof(float)) {
      eepromAddress = 0;  // Wrap around
    }
    
    // Go back to sleep
    enterSleep();
  }
}

void setupWatchdogTimer() {
  // 8-second watchdog timer
  WDTCSR = (1 << WDCE) | (1 << WDE);
  WDTCSR = (1 << WDIE) | (1 << WDP3) | (1 << WDP0);
}

ISR(WDT_vect) {
  wakeFlag = true;
}
```

### Power Measurement Tips

**Calculate Battery Life:**
```
Battery Capacity: 2000mAh
Average Current: 10mA

Runtime = Capacity / Current
        = 2000mAh / 10mA
        = 200 hours ≈ 8.3 days
```

**Use Power Profiler:**
- Multimeter in series
- Current clamp meters
- Dedicated power profiler tools

### Important Warnings

⚠️ **Brown-Out Detection**: Disable only if power is stable
⚠️ **Clock Speed**: Changing prescaler affects all timing functions
⚠️ **Pin States**: Set unused pins as INPUT_PULLUP to prevent floating

---

## 9. Input Capture and Output Compare

### Understanding Timer Features

**Arduino Uno has 3 timers with special capabilities:**

**Timer1 (16-bit):**
- **Input Capture**: Measure pulse width/frequency
- **Output Compare A/B**: Generate precise PWM, waveform generation

**Timer0 & Timer2 (8-bit):**
- **Output Compare**: PWM generation
- **Fast PWM mode**: High-frequency PWM
- **Phase-correct PWM**: Symmetrical waveforms

### Input Capture (Pulse Measurement)

**Measure pulse width with hardware precision:**
```cpp
volatile unsigned long pulseStart = 0;
volatile unsigned long pulseWidth = 0;

void setup() {
  Serial.begin(9600);
  
  // Configure Timer1 for Input Capture on pin 8 (ICP1)
  TCCR1A = 0;  // Normal mode
  TCCR1B = 0;
  
  // Rising edge trigger, no prescaler
  TCCR1B |= (1 << ICES1) | (1 << CS10);
  
  // Enable Input Capture interrupt
  TIMSK1 |= (1 << ICIE1);
  
  // Ensure pin is input
  pinMode(8, INPUT);
}

ISR(TIMER1_CAPT_vect) {
  static unsigned long lastCapture = 0;
  unsigned long captureTime = ICR1;  // Read capture register
  
  if (TCCR1B & (1 << ICES1)) {
    // Rising edge - store start time
    pulseStart = captureTime;
  } else {
    // Falling edge - calculate width
    if (captureTime >= pulseStart) {
      pulseWidth = captureTime - pulseStart;
    } else {
      // Handle timer overflow (16-bit max: 65535)
      pulseWidth = (65535 - pulseStart) + captureTime;
    }
  }
  
  // Toggle edge detection for next interrupt
  TCCR1B ^= (1 << ICES1);
}

void loop() {
  // Convert to microseconds (no prescaler = 0.0625µs per tick)
  float widthMicros = pulseWidth * 0.0625;
  
  Serial.print("Pulse Width: ");
  Serial.print(widthMicros);
  Serial.println(" µs");
  
  delay(100);
}
```

### Output Compare (Precise Timing)

**Generate exact frequency waveforms:**
```cpp
void setup() {
  // Configure Timer1 for Output Compare
  TCCR1A = 0;
  TCCR1B = 0;
  
  // CTC mode, prescaler 8
  TCCR1B |= (1 << WGM12) | (1 << CS11);
  
  // 1kHz frequency (16MHz / (2 * 8 * 1000) - 1)
  OCR1A = 999;
  
  // Toggle OC1A (pin 9) on compare match
  TCCR1A |= (1 << COM1A0);
  
  // Enable output pin
  pinMode(9, OUTPUT);
}

void loop() {
  // Stable 1kHz square wave on pin 9
}
```

**Variable Frequency Generation:**
```cpp
void setFrequency(float freqHz) {
  // Disable interrupts during update
  noInterrupts();
  
  // Calculate compare value
  // Formula: OCR1A = (16MHz / (2 * prescaler * freq)) - 1
  unsigned int prescaler = 8;
  unsigned int compareValue = (16000000L / (2 * prescaler * freqHz)) - 1;
  
  // Ensure within 16-bit range
  if (compareValue > 65535) compareValue = 65535;
  
  OCR1A = compareValue;
  
  interrupts();
}
```

### Practical Applications

**1. Infrared Remote Decoding:**
```cpp
// Measure IR pulse timings precisely
volatile unsigned long irBuffer[67];
volatile byte irIndex = 0;

ISR(TIMER1_CAPT_vect) {
  unsigned long time = ICR1;
  
  // Store each pulse/space duration
  if (irIndex < 67) {
    irBuffer[irIndex++] = time;
  }
  
  // Toggle edge detection
  TCCR1B ^= (1 << ICES1);
}
```

**2. Ultrasonic Distance Measurement:**
```cpp
// Generate 40kHz burst for ultrasonic sensor
void sendUltrasonicBurst() {
  // Configure for 40kHz
  TCCR1A = (1 << COM1A0);  // Toggle on compare
  TCCR1B = (1 << WGM12) | (1 << CS10);  // CTC, no prescaler
  
  // 40kHz: 16MHz / (2 * 1 * 40000) - 1 = 199
  OCR1A = 199;
  
  // Send 8 pulses
  delayMicroseconds(200);  // 8 * 25µs = 200µs
  
  // Stop generating
  TCCR1A = 0;
}
```

**3. Servo Control without Library:**
```cpp
void setServoAngle(int angle) {
  // Convert angle to pulse width (500-2500µs)
  int pulseWidth = map(angle, 0, 180, 500, 2500);
  
  // Configure Timer1 for precise pulse
  TCCR1A = (1 << COM1A1);  // Clear on compare, set at BOTTOM
  TCCR1B = (1 << WGM13) | (1 << CS11);  // Phase/Freq correct, prescaler 8
  
  // 20ms period (50Hz)
  ICR1 = 40000;  // 16MHz / (2 * 8 * 50) = 20000 * 2 for phase-correct
  
  // Set pulse width
  OCR1A = pulseWidth * 2;  // Convert µs to timer ticks
  
  pinMode(9, OUTPUT);
}
```

**4. Frequency Counter:**
```cpp
// Measure unknown frequency on pin 8
volatile unsigned long pulseCount = 0;
volatile unsigned long lastTime = 0;

ISR(TIMER1_CAPT_vect) {
  unsigned long captureTime = ICR1;
  pulseCount++;
  lastTime = captureTime;
}

float measureFrequency() {
  pulseCount = 0;
  
  // Gate for 1 second
  delay(1000);
  
  // Calculate frequency
  float freq = pulseCount;  // Pulses per second = Hz
  
  return freq;
}
```

### Advanced Techniques

**PWM Frequency Modification:**
```cpp
// Change PWM frequency on pins 9 & 10 (Timer1)
void setPWMFrequency(float freqHz) {
  // Disable PWM
  TCCR1A = 0;
  TCCR1B = 0;
  
  // Fast PWM mode, non-inverting
  TCCR1A = (1 << COM1A1) | (1 << COM1B1) | (1 << WGM11);
  TCCR1B = (1 << WGM13) | (1 << WGM12) | (1 << CS10);
  
  // Set frequency
  ICR1 = (16000000L / (freqHz)) - 1;
  
  // Restart PWM
  OCR1A = 0;
  OCR1B = 0;
}

// Usage: setPWMFrequency(25000); // 25kHz for silent fan control
```

**Phase-Correct vs Fast PWM:**
```cpp
// Phase-correct (center-aligned) - better for motor control
TCCR1A = (1 << COM1A1) | (1 << WGM11);
TCCR1B = (1 << WGM13) | (1 << CS10);

// Fast PWM (edge-aligned) - higher frequency possible
TCCR1A = (1 << COM1A1) | (1 << WGM11) | (1 << WGM10);
TCCR1B = (1 << WGM12) | (1 << CS10);
```

### Important Considerations

⚠️ **Timer Conflicts**: Libraries may use same timers
⚠️ **Interrupt Latency**: Consider ISR execution time
⚠️ **Register Access**: Use atomic operations when changing registers

---

## 10. Communication Protocols (SPI, I2C)

### SPI (Serial Peripheral Interface)

**Full-duplex, synchronous, high-speed communication (up to 10+ Mbps)**

**Arduino Uno SPI Pins:**
- **MOSI**: Pin 11 (Master Out Slave In)
- **MISO**: Pin 12 (Master In Slave Out)
- **SCK**: Pin 13 (Serial Clock)
- **SS**: Pin 10 (Slave Select - can be any pin)

**Basic SPI Master:**
```cpp
#include <SPI.h>

void setup() {
  SPI.begin();
  pinMode(SS, OUTPUT);
  digitalWrite(SS, HIGH);  // Deselect slave
}

byte sendReceiveSPI(byte data) {
  digitalWrite(SS, LOW);          // Select slave
  byte received = SPI.transfer(data);  // Send and receive
  digitalWrite(SS, HIGH);         // Deselect slave
  return received;
}

void loop() {
  // Send command to SPI device
  byte response = sendReceiveSPI(0xAA);
  delay(100);
}
```

**SPI Settings:**
```cpp
// Configure SPI settings
SPI.beginTransaction(SPISettings(
  1000000,    // Clock speed (1MHz)
  MSBFIRST,   // Bit order
  SPI_MODE0   // Clock polarity and phase
));

// Transfer data
SPI.transfer(data);

// End transaction
SPI.endTransaction();
```

**SPI Modes:**
```
Mode 0: CPOL=0, CPHA=0 - Clock idle LOW, sample on leading edge
Mode 1: CPOL=0, CPHA=1 - Clock idle LOW, sample on trailing edge
Mode 2: CPOL=1, CPHA=0 - Clock idle HIGH, sample on leading edge
Mode 3: CPOL=1, CPHA=1 - Clock idle HIGH, sample on trailing edge
```

### I2C (Inter-Integrated Circuit)

**Two-wire, multi-master, multi-slave communication (up to 400kbps)**

**Arduino Uno I2C Pins:**
- **SDA**: Pin A4 (Serial Data)
- **SCL**: Pin A5 (Serial Clock)
- **Pull-up resistors**: 4.7kΩ to 5V (not built-in)

**I2C Master:**
```cpp
#include <Wire.h>

void setup() {
  Wire.begin();  // Join I2C bus as master
  Serial.begin(9600);
}

void loop() {
  // Request data from device at address 0x68
  Wire.beginTransmission(0x68);     // Start talking to device
  Wire.write(0x00);                 // Send register address
  Wire.endTransmission(false);      // Restart condition
  
  // Request 2 bytes
  Wire.requestFrom(0x68, 2);
  
  if (Wire.available() >= 2) {
    byte msb = Wire.read();
    byte lsb = Wire.read();
    
    int value = (msb << 8) | lsb;
    Serial.println(value);
  }
  
  delay(100);
}
```

**I2C Scanner:**
```cpp
#include <Wire.h>

void setup() {
  Wire.begin();
  Serial.begin(9600);
  Serial.println("I2C Scanner");
}

void loop() {
  byte error, address;
  int devices = 0;
  
  Serial.println("Scanning...");
  
  for(address = 1; address < 127; address++) {
    Wire.beginTransmission(address);
    error = Wire.endTransmission();
    
    if (error == 0) {
      Serial.print("Device found at 0x");
      if (address < 16) Serial.print("0");
      Serial.println(address, HEX);
      devices++;
    }
  }
  
  if (devices == 0) {
    Serial.println("No I2C devices found");
  }
  
  delay(5000);
}
```

### Practical Applications

**1. OLED Display (I2C):**
```cpp
#include <Wire.h>
#include <Adafruit_SSD1306.h>

Adafruit_SSD1306 display(128, 64, &Wire);

void setup() {
  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(WHITE);
  
  display.setCursor(0,0);
  display.println("Hello, OLED!");
  display.display();
}
```

**2. SD Card (SPI):**
```cpp
#include <SPI.h>
#include <SD.h>

File dataFile;

void setup() {
  Serial.begin(9600);
  
  if (!SD.begin(10)) {  // CS on pin 10
    Serial.println("SD card failed");
    return;
  }
  
  dataFile = SD.open("data.txt", FILE_WRITE);
  if (dataFile) {
    dataFile.println("Data logging started");
    dataFile.close();
  }
}

void loop() {
  dataFile = SD.open("data.txt", FILE_WRITE);
  dataFile.println(millis());
  dataFile.close();
  delay(1000);
}
```

**3. RTC Module (I2C):**
```cpp
#include <Wire.h>
#include "RTClib.h"

RTC_DS3231 rtc;

void setup() {
  rtc.begin();
  
  if (rtc.lostPower()) {
    // Set to compile time
    rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
  }
}

void loop() {
  DateTime now = rtc.now();
  
  Serial.print(now.year());
  Serial.print('/');
  Serial.print(now.month());
  Serial.print('/');
  Serial.print(now.day());
  Serial.print(' ');
  Serial.print(now.hour());
  Serial.print(':');
  Serial.print(now.minute());
  Serial.print(':');
  Serial.println(now.second());
  
  delay(1000);
}
```

**4. Multiple SPI Devices:**
```cpp
const int SD_CS = 10;
const int LCD_CS = 9;
const int ETH_CS = 8;

void setup() {
  SPI.begin();
  
  pinMode(SD_CS, OUTPUT);
  pinMode(LCD_CS, OUTPUT);
  pinMode(ETH_CS, OUTPUT);
  
  digitalWrite(SD_CS, HIGH);
  digitalWrite(LCD_CS, HIGH);
  digitalWrite(ETH_CS, HIGH);
}

void selectDevice(int csPin) {
  // Deselect all
  digitalWrite(SD_CS, HIGH);
  digitalWrite(LCD_CS, HIGH);
  digitalWrite(ETH_CS, HIGH);
  
  // Select requested device
  digitalWrite(csPin, LOW);
}
```

### Communication Tips

**SPI Tips:**
- Keep wires short for high-speed communication
- Use proper ground connections
- Consider level shifters for 3.3V devices

**I2C Tips:**
- Add external pull-up resistors (4.7kΩ typical)
- Use I2C scanner to detect devices
- Handle bus collisions in multi-master setups

**Error Handling:**
```cpp
byte writeI2C(byte address, byte reg, byte data) {
  Wire.beginTransmission(address);
  Wire.write(reg);
  Wire.write(data);
  byte error = Wire.endTransmission();
  
  if (error != 0) {
    Serial.print("I2C error: ");
    Serial.println(error);
  }
  
  return error;
}
```

### Performance Comparison

```
Protocol  Speed       Wires  Complexity  Best For
--------- ----------  -----  ----------  -----------------
UART      Up to 1Mbps   2     Simple     PC communication
SPI       Up to 10+Mbps 4+    Moderate   High-speed devices
I2C       Up to 400kbps 2     Complex    Multiple devices, sensors
```

---

## 11. Advanced Interfacing Techniques

### Signal Conditioning

**1. Voltage Level Shifting:**
```cpp
// 5V ↔ 3.3V bidirectional level shifter
// Use dedicated level shifter ICs (TXB0108, PCA9306)
// Or resistor divider for 5V→3.3V (unidirectional)

float voltageDivider(float inputVoltage, float R1, float R2) {
  return inputVoltage * (R2 / (R1 + R2));
}

// For 5V→3.3V: R1=10kΩ, R2=20kΩ
// Output = 5V * (20k / (10k + 20k)) = 3.33V
```

**2. Analog Signal Filtering:**
```cpp
// RC low-pass filter for noise reduction
// f_cutoff = 1 / (2πRC)
// Example: 100Hz cutoff with 10kΩ resistor:
// C = 1 / (2π * 100 * 10000) ≈ 0.16µF

// Software filtering
float exponentialFilter(float newValue, float oldValue, float alpha) {
  return alpha * newValue + (1 - alpha) * oldValue;
}
```

### Motor Control

**1. H-Bridge for DC Motor Control:**
```cpp
// L298N H-Bridge example
const int ENA = 9;   // PWM speed control
const int IN1 = 8;   // Direction
const int IN2 = 7;   // Direction

void setupMotor() {
  pinMode(ENA, OUTPUT);
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
}

void setMotor(int speed, bool forward) {
  // Constrain speed to PWM range
  speed = constrain(abs(speed), 0, 255);
  
  // Set direction
  digitalWrite(IN1, forward ? HIGH : LOW);
  digitalWrite(IN2, forward ? LOW : HIGH);
  
  // Set speed
  analogWrite(ENA, speed);
}

void brakeMotor() {
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, HIGH);
  analogWrite(ENA, 0);
}
```

**2. Stepper Motor Control:**
```cpp
// ULN2003 driver for 28BYJ-48 stepper
const int stepsPerRevolution = 2048;
const int motorPins[] = {8, 9, 10, 11};
const byte stepSequence[8][4] = {
  {1, 0, 0, 0},
  {1, 1, 0, 0},
  {0, 1, 0, 0},
  {0, 1, 1, 0},
  {0, 0, 1, 0},
  {0, 0, 1, 1},
  {0, 0, 0, 1},
  {1, 0, 0, 1}
};

void stepMotor(int step) {
  for(int pin = 0; pin < 4; pin++) {
    digitalWrite(motorPins[pin], stepSequence[step][pin]);
  }
}

void rotateStepper(int steps, int delayTime) {
  static int currentStep = 0;
  
  for(int i = 0; i < abs(steps); i++) {
    stepMotor(currentStep);
    delay(delayTime);
    
    if(steps > 0) {
      currentStep = (currentStep + 1) % 8;
    } else {
      currentStep = (currentStep + 7) % 8;
    }
  }
}
```

### Sensor Integration

**1. Multiple Sensor Reading Pattern:**
```cpp
struct SensorData {
  float temperature;
  float humidity;
  int lightLevel;
  bool motion;
};

SensorData readAllSensors() {
  SensorData data;
  
  // Read each sensor
  data.temperature = readDS18B20();
  data.humidity = readDHT22();
  data.lightLevel = analogRead(LDR_PIN);
  data.motion = digitalRead(PIR_PIN);
  
  return data;
}
```

**2. Sensor Fusion:**
```cpp
// Combine accelerometer and gyroscope data
float complementaryFilter(float accelAngle, float gyroRate, float dt) {
  static float angle = 0;
  const float alpha = 0.98;  // Trust gyro 98%, accel 2%
  
  // Integrate gyro rate
  angle += gyroRate * dt;
  
  // Fuse with accelerometer
  angle = alpha * angle + (1 - alpha) * accelAngle;
  
  return angle;
}
```

### Real-Time Operating System (RTOS) Concepts

**Task Scheduler:**
```cpp
struct Task {
  void (*function)();
  unsigned long interval;
  unsigned long lastRun;
};

Task tasks[5];
int taskCount = 0;

void createTask(void (*func)(), unsigned long interval) {
  tasks[taskCount].function = func;
  tasks[taskCount].interval = interval;
  tasks[taskCount].lastRun = millis();
  taskCount++;
}

void scheduler() {
  unsigned long now = millis();
  
  for(int i = 0; i < taskCount; i++) {
    if(now - tasks[i].lastRun >= tasks[i].interval) {
      tasks[i].function();
      tasks[i].lastRun = now;
    }
  }
}

void loop() {
  scheduler();
  // Other continuous tasks
}
```

### Error Handling and Recovery

**Watchdog with Recovery:**
```cpp
#include <avr/wdt.h>

void setup() {
  wdt_enable(WDTO_4S);  // 4-second watchdog
  
  if (MCUSR & (1 << WDRF)) {
    // Watchdog reset occurred
    logError("System recovered from watchdog reset");
    MCUSR = 0;
  }
  
  // Initialize system
  initializeSystem();
}

void loop() {
  // Main tasks
  readSensors();
  controlOutputs();
  
  // Reset watchdog
  wdt_reset();
}
```

**Safe System States:**
```cpp
enum SystemState {
  STATE_INIT,
  STATE_NORMAL,
  STATE_ERROR,
  STATE_RECOVERY
};

SystemState currentState = STATE_INIT;

void systemManager() {
  switch(currentState) {
    case STATE_INIT:
      if(initializeHardware()) {
        currentState = STATE_NORMAL;
      } else {
        currentState = STATE_ERROR;
      }
      break;
      
    case STATE_NORMAL:
      if(checkForErrors()) {
        currentState = STATE_ERROR;
      }
      break;
      
    case STATE_ERROR:
      logError("System error detected");
      enterSafeMode();
      currentState = STATE_RECOVERY;
      break;
      
    case STATE_RECOVERY:
      if(attemptRecovery()) {
        currentState = STATE_NORMAL;
      }
      break;
  }
}
```

### Best Practices Summary

**✅ DO:**
- Use proper voltage level shifting
- Implement error checking and recovery
- Add filtering for noisy signals
- Use non-blocking code patterns
- Monitor memory usage
- Implement watchdog timers

**❌ DON'T:**
- Connect devices directly without checking voltage levels
- Use blocking delays in main loops
- Ignore current limitations
- Forget to debounce switches
- Skip input validation

**Debugging Tips:**
```cpp
void debugPrint(const char* message, int value = -9999) {
#ifdef DEBUG_MODE
  Serial.print("[DEBUG] ");
  Serial.print(message);
  if(value != -9999) {
    Serial.print(": ");
    Serial.print(value);
  }
  Serial.println();
#endif
}

// Usage:
debugPrint("Sensor value", sensorReading);
```

---

## Conclusion

Arduino's feature set, from basic GPIO to advanced communication protocols, provides a versatile platform for embedded systems development. Key takeaways:

1. **Start Simple**: Master GPIO, ADC, and PWM before moving to advanced features
2. **Think About Power**: Implement sleep modes for battery-powered projects
3. **Use Proper Interfacing**: Always consider voltage levels and current limits
4. **Write Robust Code**: Include error handling and recovery mechanisms
5. **Optimize When Needed**: Only optimize memory/power after identifying bottlenecks
6. **Leverage Libraries**: Use community libraries for complex peripherals
7. **Test Incrementally**: Test each feature before integrating into larger systems

### Next Steps for Learning:

1. **Explore Arduino Libraries**: Many complex features have simplified libraries
2. **Study Hardware Datasheets**: Understand your microcontroller's capabilities
3. **Practice with Projects**: Start with tutorials, then create original designs
4. **Learn Debugging Techniques**: Use serial output, LEDs, and logic analyzers
5. **Join the Community**: Arduino Forum and StackExchange are valuable resources

### Project Ideas to Apply These Features:

1. **Home Automation System**: Use I2C for sensors, PWM for lighting control
2. **Weather Station**: Implement low-power sleep modes, data logging
3. **Robot Controller**: Combine motor control, sensors, and communication
4. **Audio Visualizer**: Use ADC for audio input, PWM for LED control
5. **Industrial Monitor**: Implement robust communication and error recovery

Remember: The best way to learn is by doing. Start with simple projects and gradually incorporate more advanced features as you gain confidence.

---

*This guide covers the core features of Arduino microcontrollers. For specific applications or advanced topics, refer to the official Arduino documentation, datasheets, and community resources.*
